<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures and Algorithms Summary</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            background-color: #030303;
            color: #212529;
            margin: 0;
            padding: 20px;
        }
       
        h1, h2, h3 {
            color: #007bff;
        }
        h1 {
            text-align: center;
            text-transform: uppercase;
            margin-bottom: 20px;
            color: #fefeff;
            background-color: #039311;
            padding: 10px;
            border-radius: 5px;
        }
        h2 {
            margin-top: 30px;
            border-bottom: 2px solid #0f0f10;
            padding: 10px;
            background-color: #30da2d;
            border-radius: 4px;
            color: #020202;
        }
        h3 {
            margin-top: 20px;
            font-style: italic;
        }
        ul {
            list-style-type: disc;
            margin: 15px 20px;
        }
        li {
            margin-bottom: 8px;
        }
        code {
            background-color: #dfe6ed;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.95em;
        }
        p {
            margin: 15px 0;
        }
        strong {
            color: #343a40;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #d0f9bd;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .note {
            font-size: 0.9em;
            background-color: #f8f9fa;
            border-left: 4px solid #6da4de;
            padding: 10px;
            margin-top: 10px;
        }
        footer {
            text-align: center;
            margin-top: 40px;
            font-size: 0.9em;
            color: #6a7077;
        }
    .navbar {
    position: sticky;
    top: 0;
    background-color:  #0c540e;
    width: 100%;
    z-index: 1000;
    padding: 0.5rem 1rem;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
    display: flex;
    border-radius: 10px;
    justify-content: center;
    justify-content: space-between;
  }

 
  
  .nav-list {
    list-style: none;
    display: flex;
    justify-content: space-around;
    align-content: center;
    margin: 0;
    padding: 0;
    
  }
  
  .nav-list li {
    margin: 0;
    color: #866545;
  }
  
  .nav-list a {
    text-decoration: none;
    color: #FB5235;
    align-content: center;
    padding: 1rem 1rem;
    transition: background-color 0.3s ease;
  }
  
  .nav-list a:hover {
    transform: scale(1.02);  
    background-color: #2fef2c;
   
    box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);  
    transition: transform 0.2s, box-shadow 0.2s;
    border-radius: 4px;
  }
  
  .content {
    padding: 2rem;
    font-size: 1.2rem;
    line-height: 1.6;
  }
    </style>
</head>
<body>
    <nav class="navbar">
        <ul class="nav-list">
            <li><a style="color:rgb(255, 255, 255)"  href="/Priyankacb.github.io/blocks/home/home.html">Home</a></li>
            <li><a style="color:rgb(255, 255, 255)"  href="/Priyankacb.github.io/index.html">PROJECT OVERVIEW</a></li>
            <li><a  style="color:rgb(253, 251, 251)" href="/Priyankacb.github.io/blocks/learningref/teamlearning.html">Learning Reflections</a></li>
        </ul>
    </nav>
  <section>
    
        <h1>Data Structures and Algorithms </h1>
        <div class="container">
        <h2>1. What are the kinds of problems we see in nature?</h2>
        <ul>
           <li><strong>Definition:</strong> Repeatedly applying a set of instructions until a condition is met.</li>
           <li><strong>Examples:</strong>
             <ul>
                <li>Population growth simulations.</li>
                <li>Compound interest calculations.</li>
            </ul>
    </li>
        </ul>
            <h3>Recursion</h3>
<ul>
    <li><strong>Definition:</strong> Breaking a problem into smaller instances of the same problem.</li>
    <li><strong>Examples:</strong>
        <ul>
            <li>Computing factorials or Fibonacci numbers.</li>
            <li>Tower of Hanoi problem.</li>
        </ul>
    </li>
</ul>
            <h3>Backtracking</h3>
<ul>
    <li><strong>Definition:</strong> Exploring all possible options to find a solution and reverting decisions when a dead-end is reached.</li>
    <li><strong>Examples:</strong>
        <ul>
            <li>Solving mazes.</li>
            <li>Generating permutations.</li>
        </ul>
    </li>
</ul>

    </div>
    
    <div class="container">
        <h2>2. What is space and time efficiency? Why are they important? Explain the different classes of problems and orders of growth</h2>
        <ul>
            <li>Space efficiency refers to the amount of memory an algorithm uses, and time efficiency refers to the amount of time it takes to complete. These are critical factors in algorithm design, especially when working with large datasets or in resource-constrained environments</li>
           
        </ul>
    
    
        <h2>Why are They Important?</h2>
        <ul>
            <li>Algorithms are classified based on their time and space complexities, using Big O notation to express the order of growth. Common classes of problems include linear (O(n)), logarithmic (O(log n)), quadratic (O(nÂ²)), and exponential (O(2^n)) complexities.</li>
        </ul>
    </div>

    <div class="container">
        <h2>3. Take away from different design principles from chapter 2</h2>
    </div>

    <div class="container">
        <h2>4. The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)</h2>
        <h3>Ans:</h3>
        <ul>
           <li><strong>Binary Search Tree (BST):</strong> Allows efficient searching, insertion, and deletion.</li>
    <li><strong>AVL Tree:</strong> Self-balancing BST ensuring logarithmic operations.</li>
    <li><strong>2-3 Tree:</strong> Balanced search tree allowing multiple keys per node.</li>
    <li><strong>Red-Black Tree:</strong> Ensures balanced height using coloring rules.</li>
    <li><strong>Heap:</strong> Used in priority queues with efficient min/max access.</li>
    <li><strong>Trie:</strong> Optimizes prefix-based queries like dictionary lookups.</li>
            </ul>

        <h3>Optimization Scenarios</h3>
<ul>
    <li><strong>Applications:</strong>
        <ul>
            <li>Database indexing.</li>
            <li>Autocomplete systems.</li>
            <li>Task scheduling.</li>
        </ul>
    </li>
        </ul>
    </div>

    <div class="container">
        <h2>5. The need for array query algorithms and their implications. Their applications and principles need to be discussed</h2>
        <h3>Ans:</h3>
        <ul>
            <li>Array query algorithms are essential for efficiently accessing, updating, and processing elements in large arrays. Efficient algorithms allow us to search, sort, or manipulate data quickly. Applications include range queries in databases, searching for patterns in data, and optimizing data access in caches or memory.</li>
        </ul>
    </div>

    <div class="container">
        <h2>6. Differentiate between tree and graphs and their traversals. The applications of each</h2>
        <h3>Ans:</h3>
        <ul>
            <li><strong>Difference Between Trees and Graphs:</strong> A tree is a hierarchical structure where each node has a single parent and zero or more children. A graph, on the other hand, is a set of vertices connected by edges, and nodes can have multiple relationships with each other. Trees are a specific kind of graph that doesn't have cycles, while graphs can have cycles.</li>
            <li><strong>Traversals:</strong> Both trees and graphs have various ways to traverse through their elements:</li>
            <ul>
                <li><strong>Tree Traversals:</strong>
                    <ul>
                        <li><strong>Preorder Traversal:</strong> Visit the root, then the left subtree, followed by the right subtree.</li>
                        <li><strong>Inorder Traversal:</strong> Visit the left subtree, then the root, followed by the right subtree.</li>
                        <li><strong>Postorder Traversal:</strong> Visit the left subtree, then the right subtree, and finally the root.</li>
                        <li><strong>Level Order Traversal:</strong> Visit all nodes at each level from top to bottom.</li>
                    </ul>
                </li>
                <li><strong>Graph Traversals:</strong>
                    <ul>
                        <li><strong>BFS (Breadth-First Search):</strong>Explores all nodes at the present depth level before moving on to nodes at the next depth level.
</li>
                        <li><strong>DFS (Depth-First Search):</strong> Explores as deep as possible before backtracking.
</li>
                    </ul>
                </li>
            </ul>
        </ul>
    </div>
     <div class="container">
        <h2>7.Deliberate on sorting and searching algorithms, the technique behind each and their connection to the real world</h2>
         <h3>Ans:</h3>
           <ul>
               <li><strong>Sorting algorithms:</strong> These algorithms are used to arrange data in a specific order, such as ascending or descending. Sorting is essential in various computational tasks like data analysis, searching, and optimizing processes.</li>
               <li><strong>Bubble sort:</strong>This algorithm repeatedly compares adjacent elements in a list and swaps them if they are in the wrong order. While it's easy to implement, bubble sort is inefficient for large datasets due to its time complexity.</li>
               <li><strong>Selection sort:</strong> Selection sort works by finding the smallest (or largest) element in a list and swapping it with the first unsorted element, repeating the process until the entire list is sorted.</li>
               <li><strong>Insertion sort:</strong>Insertion sort builds the final sorted array one element at a time. It repeatedly compares and places the current element in its correct position relative to the sorted portion of the list.</li>
               <li><strong>Merge sort:</strong>Merge sort divides the data into smaller chunks, sorts them individually, and then merges them back together in order. It's highly efficient for large datasets and operates with a time complexity of O(n log n).</li>
               <li><strong>Quick sort:</strong>Quick sort selects a "pivot" element and partitions the data into two groups: one containing elements smaller than the pivot, and the other containing elements larger. It recursively sorts the subgroups. It's known for its efficiency in most cases.</li>
               <li><strong>Heap sort:</strong>Heap sort utilizes a heap data structure to sort elements. It is particularly effective for large datasets and is useful in priority queue applications.</li>li>
                <li><strong>Linear Search:</strong>This basic search method looks at each element of the list sequentially until it finds the target value. It's simple but inefficient for large datasets</li>
                <li><strong>Binary Search:</strong>Binary search operates on sorted arrays by dividing the search range in half repeatedly, allowing it to efficiently locate an element with a time complexity of O(log n).</li>
             <li><strong>Real world connection:</strong>orting and searching are fundamental in various real-world applications, such as databases, search engines, operating systems, and even in web applications, where efficiency and speed are critical.

</li>
           </ul>
       </div>
       <div class="container">
        <h2>8..Discuss the importance of graph algorithms with respect to spanning trees and shortest path.</h2>
         <h3>Ans:</h3>
           <ul>
               <li>Graph algorithms play a crucial role in solving real-world problems involving networks, transportation, and logistics. Spanning tree algorithms like Kruskalâs and Primâs are important for finding the minimum set of edges to connect all vertices in a graph without cycles, which is useful in network design. Shortest path algorithms like Dijkstraâs and Bellman-Ford are essential for finding the quickest route between two points, which has applications in GPS navigation, flight routing, and communication networks.
</li>
           </ul>
       </div>
       <div class="container">
       <h2>9.Discuss about the different studied algorithm design techniques.</h2>
        <h3>Ans:</h3>
      <ul>
      </li>Several algorithm design techniques have been studied in this course, each with its own applications and advantages. These include</li>
         <li><strong>Divide and conquer:</strong> This technique involves breaking a problem into smaller sub-problems, solving each recursively, and combining the results. Examples include Merge Sort and Quick Sort.</li>
          <li><strong>Dynamic programming:</strong>This technique solves problems by breaking them into overlapping subproblems and storing the results of these subproblems to avoid redundant computations. Examples include the Fibonacci sequence and the Knapsack problem.</li>
          <li><strong>Greedy algorithms:</strong> These algorithms build solutions step-by-step, choosing the locally optimal choice at each step, with the hope of finding a globally optimal solution. Examples include the Huffman coding algorithm and Kruskalâs algorithm.</li>
          <li><strong>Backtracking:</strong>Used to explore all possible solutions by systematically searching through the space of possible solutions and undoing steps when a condition is violated. Examples include solving the N-Queens problem and finding a path in a maze.</li>
       </ul>
    </div>
  </section>
  <button onclick="window.history.back();" style="background-color: #0bb12f; color: rgb(241, 233, 233); border: none; padding: 10px 20px; font-size: 1rem; cursor: pointer; border-radius: 5px; margin-bottom: 20px;">Back</button>
</body> 
</html>

